// #include "UnityCG.cginc"
#include "../GlobalDefines.cginc"

#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "CommonData.cginc"
#include "Materials.cginc"
#include "../Utility/Atmosphere/AtmosphereSampling.cginc"

#ifdef HDRP
    Texture2DArray<float2> MotionVectors;
#else
    Texture2D<float2> MotionVectors;
#endif


#pragma kernel kernel_shade

int BackgroundType;
float3 BackgroundColor;
float BackgroundIntensity;
bool ImprovedPrimaryHit;
bool ClayMode;

//These are here purely for the Atrous
#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
bool VisabilityCheck(Ray ray, float dist) {
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
        while(q.Proceed()){}

        if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) return false;
        else return true;
    #else
    return VisabilityCheckCompute(ray, dist);
    #endif
}

#ifdef RadianceCache
inline void calcFinalColor(SmallerRay ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 id, float2 NormalUV, RayData RayDat, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float4 PrevScreenData, inout PropogatedCacheData CacheInstance) {//main function
#else
inline void calcFinalColor(SmallerRay ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 id, float2 NormalUV, RayData RayDat, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float4 PrevScreenData) {//main function
#endif
    bool CB = !DoPartialRendering;
    if(!CB) {
        CB = (int(id.x)/2 + int(id.y)/2 + curframe)%PartialRenderingFactor==0;
        if(UseASVGF || (UseReSTIRGI && ReSTIRGIUpdateRate != 0)) {
            if(RandomNums[id].z != 0 || RandomNums[id].w != 0) CB = true;
        }
    }
    float3 PrevOrigin = ray.origin;
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 Geomnorm;
    float3 USGNorm;//Unsmoothed geometric normal
    float3 norm;
    float3x3 Inverse = transpose((float3x3)_MeshData[hit.mesh_id].W2L);
    float pdf = 0.0f;
    bool validBSDFSample;

    float3 throughput = Color.throughput;
    [branch] if (TerrainExists && hit.mesh_id == 9999999) {
        Geomnorm = GetHeightmapNormal(pos, hit.triangle_id);
        USGNorm = Geomnorm;
    } else {
        Geomnorm = GetTriangleNormal(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        USGNorm = mul(Inverse, cross(normalize(AggTris[hit.triangle_id].posedge1), normalize(AggTris[hit.triangle_id].posedge2)));
        float wldScale = rsqrt(dot(USGNorm, USGNorm));
        USGNorm = -mul(wldScale, USGNorm);
        if(dot(USGNorm, Geomnorm) < 0) USGNorm *= -1;
        if(hitDat.MatType == CutoutIndex) USGNorm = Geomnorm;
    }

    bool GotFlipped = dot(ray.direction, USGNorm) > 0.0f;
    if (GotFlipped) {USGNorm *= -1.0f; Geomnorm *= -1.0f;}//Backfacing surface

    Geomnorm = i_octahedral_32(octahedral_32(Geomnorm));
    norm = Geomnorm;

    [branch]if(CurBounce == 0 && UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id].z != 0 && hitDat.specTrans == 0 && hitDat.diffTrans == 0) {
        norm = i_octahedral_32(asuint(RandomNums[id].w));
    } else if (!ClayMode && NormalUV.x != -1) {//Handle Normal Maps
        float3 LocalTan = GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = _NormalAtlas.SampleLevel(sampler_NormalAtlas, NormalUV, 0);

        float3 LocalNormIN = float3((hitDat.NormalStrength * Norm - (hitDat.NormalStrength / 2.0f)), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);
        norm = clamp(normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz),-1,1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
        norm = i_octahedral_32(octahedral_32(norm));
    }
    if(CurBounce == 0 && UseASVGF && RandomNums[id].w == 1 && !(hitDat.metallic == 1 && hitDat.roughness < 0.05f)) {
        Geomnorm = i_octahedral_32(asuint(PrevScreenData.x));
        norm = i_octahedral_32(asuint(PrevScreenData.y));
    }

    {
        [branch]if(hitDat.MatCapTex.x > 0) {
            float3 worldViewUp = normalize(float3(0, 1, 0) - ray.direction * dot(ray.direction, float3(0, 1, 0)));
            float3 worldViewRight = normalize(cross(ray.direction, worldViewUp));
            
            float2 matcapUV = float2(dot(worldViewRight, norm), dot(worldViewUp, norm)) * 0.5f + 0.5;

            float2 MatCapUV = AlignUV(matcapUV, hitDat.AlbedoTexScale, hitDat.MatCapTex, hitDat.Rotation, true);
            float4 matcap = _TextureAtlas.SampleLevel(my_linear_clamp_sampler, MatCapUV, 0);
            float2 MatCapMaskUV = AlignUV(BaseUv, hitDat.AlbedoTexScale, hitDat.MatCapMask, hitDat.Rotation, true);
            if(MatCapMaskUV.x != -1) {
                hitDat.surfaceColor = lerp(hitDat.surfaceColor, matcap.xyz, SingleComponentAtlas.SampleLevel(my_linear_clamp_sampler, MatCapMaskUV, 0).x);
            }
        }
    }


    [branch] if (hitDat.emmissive > 0.0f) {//if we hit a light, this ray is done
        #ifdef WhiteLights
            hitDat.surfaceColor = 0.5f;
        #endif
        float3 EmissCol = hitDat.surfaceColor * hitDat.emmissive;
        if (!UseNEE || hitDat.MatType == VideoIndex) {
            if (CurBounce <= 1) Color.Direct += EmissCol;
            #ifndef RadianceCache
                if(CurBounce > 1) Color.Indirect += Color.throughput * EmissCol;
            #else
                CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + Color.throughput * EmissCol * abs(dot(i_octahedral_32(CacheInstance.Norm), ray.direction)));
                if(!((CacheInstance.pathLength >> 5) & 0x1))
                    Color.Indirect += Color.throughput * EmissCol;
            #endif
        } else {
            float3 a1 = mul((float3x3)inverse(_MeshData[hit.mesh_id].W2L), AggTris[hit.triangle_id].posedge1).xyz;
            float3 a2 = mul((float3x3)inverse(_MeshData[hit.mesh_id].W2L), AggTris[hit.triangle_id].posedge2).xyz;
            float a = AreaOfTriangle(float3(0,0,0), a1, a2);
            float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
            float light_pdf = 1.0f / (SA * LightMeshCount);
            #ifdef LBVH
                #ifdef FasterLightSampling
                    light_pdf *= rcp(_MeshData[hit.mesh_id].LightTriCount);
                #else
                    CalcLightPDF(light_pdf, ray.origin, pos, ray.direction, pixel_index, hit.mesh_id);
                #endif
            #else
                light_pdf *= rcp(_MeshData[hit.mesh_id].LightTriCount);
            #endif
            float w = power_heuristic(max(RayDat.last_pdf,0), light_pdf);
            if (CurBounce == 0) Color.Direct += EmissCol;
            else if (CurBounce == 1) Color.Direct += EmissCol * w;
            #ifndef RadianceCache
                else Color.Indirect += Color.throughput * EmissCol * w;
            #else
                CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + Color.throughput * EmissCol * w);
                if(!((CacheInstance.pathLength >> 5) & 0x1))
                    Color.Indirect += Color.throughput * EmissCol * w;
            #endif
        }
        if(CurBounce == 0 && !(id.x == screen_width / 2 && id.y == screen_height / 2-1)) PrevScreenData.z = -10000.0f;
        if(luminance(EmissCol) > 12.0f || hitDat.MatType == VideoIndex) {
            if(CurBounce == 0) Color.Data = float4( hitDat.MatType == VideoIndex ? hitDat.surfaceColor : EmissCol, 0);
            #ifdef RadianceCache
                if(!UseReSTIRGI || ReSTIRGIUpdateRate == 0 || RandomNums[id.xy].z == 0) {
                    if(hit.t >= CalcVoxelSize(pos)) {
                        if(!AddHitToCache(CacheInstance, PrevOrigin, random(324, pixel_index).x)) return;
                        CacheInstance.CurrentIlluminance = 0;
                    }
                }
            #endif
            return;
        }
    }
   

    [branch]if(ClayMode) {
        hitDat.surfaceColor = ClayColor;
        hitDat.metallic = 0;
        hitDat.clearcoat = 0;
        hitDat.specTrans = 0;
        hitDat.sheen = 0;
        hitDat.Specular = 0;
    }

    int MaterialLobe = 2;
    bool Refracted = false;
    float3 bsdf = 1;
    [branch] if(CurBounce == 0 && UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id].z != 0) {
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(id,0)].xy;
        #else
           float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id) / float2(screen_width, screen_height) , 0).xy;
        #endif
        uint2 prevIndexDoub = int2(floor(((float2(id) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));

        ray.direction = normalize(CalcPos(WorldPosB[prevIndexDoub]) - (pos + USGNorm * NormalOffset));
        MaterialLobe = RandomNums[id].z - 1;
        validBSDFSample = ReconstructBsdf(hitDat, PrevDirection, ray.direction, norm, pdf, bsdf, GetTangentSpace(norm), pixel_index, MaterialLobe);
    } else validBSDFSample = SampleDisney(hitDat, ray.direction, GetFlag(hitDat.Tag, Thin), pdf, bsdf, norm, MaterialLobe, pixel_index, Refracted, GotFlipped);

    {
        if (CurBounce == 0) {
            float Metallic = saturate(hitDat.metallic + ((!UseASVGF || UseReSTIRGI) ? 0 : hitDat.Specular));
            if (MaterialLobe == 3) Color.MetRoughIsSpec = ToColorSpecPacked(float3(0, Refracted ? 0.6f : 0.39f, 2 + !Refracted));
            else Color.MetRoughIsSpec = ToColorSpecPacked(float3(Metallic, hitDat.roughness, MaterialLobe));
        }

        if (Refracted) {
            Geomnorm *= -1;
            norm *= -1;
            USGNorm *= -1;
            CB = true;
        } else if (Color.Data.w <= 0 && MaterialLobe == 3) {
            Color.MetRoughIsSpec = ToColorSpecPacked(float3(0, 0, 3));
        }
        if(!GetFlag(hitDat.Tag, Thin) && GotFlipped && hitDat.specTrans != 0 && hit.mesh_id != 9999999)
            bsdf *= exp(-hit.t * CalculateExtinction(1.0f - hitDat.surfaceColor, hitDat.scatterDistance == 0.0f ? 1.0f : hitDat.scatterDistance));

        throughput *= bsdf;
    }

    ray.origin = USGNorm * NormalOffset + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of

    [branch] if (CurBounce == 0 || Color.Data.w == -1) {//Setting textures for denosier to use
        Color.Flags = packRGBE((CurBounce == 0) ? max(hitDat.surfaceColor, 0.005f) : (unpackRGBE(Color.Flags) * max(hitDat.surfaceColor, 0.005f)));
        PrevScreenData = float4(asfloat(octahedral_32((CurBounce == 0 && Refracted) ? -Geomnorm : Geomnorm)), asfloat(octahedral_32((CurBounce == 0 && Refracted) ? -norm : norm)),PrevScreenData.z + hit.t, asfloat(((uint)(MaterialIndex << 2) >> 2) | ((CurBounce != 0 ? ((asuint(PrevScreenData.w) << 1) >> 30) :  (uint)MaterialLobe) << 29) | (Refracted << 31))); 
        Color.MetRoughIsSpec |= (Refracted << 31);
        Color.Data = float4(((CurBounce == 0) ? max(throughput, 0.005f) : (max(throughput, 0.005f) * Color.Data.xyz)), (UseASVGF && ((MaterialLobe == 3 && hitDat.roughness < 0.25f) || (hitDat.metallic == 1 && MaterialLobe == 0 && hitDat.roughness < 0.01f && CurBounce == 0))) ? -1 : (CurBounce + 1));  
        throughput = 1;  
    }   
    #ifdef RadianceCache
        #ifdef RadianceDebug
            if(CurBounce == 0) _DebugTex[id.xy] = float4(ray.origin, asfloat(octahedral_32(norm)));
        #endif
        if(CurBounce > 0 && (CacheInstance.pathLength >> 5) & 0x1) {
            float3 res2 = 0;
            if((hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(324, pixel_index).x))) {
                if(RetrieveCacheRadiance(CacheInstance, ray.origin, norm, res2)) {
                // CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + throughput * res2 * (MaterialLobe == 3 ? 1 : abs(dot(norm, ray.direction))));//fabled "infinite bounce" - VERY hard to weight properly
                    Color.Indirect += Color.throughput * res2;
                }
            }
            CacheInstance.pathLength |= (1u << 6);
        } else if((!(MaterialLobe == 0 && hitDat.roughness < 0.05) && MaterialLobe != 3)) CacheInstance.pathLength |= (1u << 5);

        if(CurBounce > 0 && (!UseReSTIRGI || ReSTIRGIUpdateRate == 0 || RandomNums[id.xy].z == 0)) {
            if((CacheInstance.pathLength >> 6) & 0x1) {
                if(!AddHitToCache(CacheInstance, PrevOrigin, random(324, pixel_index).y)) return;
                CacheInstance.CurrentIlluminance = 0;
            }
        }

        CacheInstance.Norm = octahedral_32(norm);
        CachePropogateBSDF(CacheInstance, bsdf * (MaterialLobe == 3 ? 1 : abs(dot(norm, ray.direction))));
    #endif

    [branch] if (hitDat.specTrans == 0 && (UseNEE) && CurBounce < MaxBounce && (BackgroundType == 1 || unitylightcount + LightMeshCount != 0) && CB) {//Next event estimation
        float3 LightNorm;
        float3 LightPosition;
        int LightFormat = TRILIGHT;
        float3 Radiance;
        float RunningWeight = 1;
        float area = 1;
        float3 MiscInfo = 0;
        int AggTriIndex = 0;
        int SelectedLightGroup = 0;//0 = primitive, 1 = point, spot, etc., 2 = skybox
        int selectionoptions = 0;
        int selections[3] = {0,0,0};
        if(LightMeshCount != 0) selections[selectionoptions++] = 0;
        if(unitylightcount != 0) selections[selectionoptions++] = 1;
        if(BackgroundType == 1) selections[selectionoptions++] = 2;
        RunningWeight = selectionoptions;
        SelectedLightGroup = selections[min(floor(random(114, pixel_index).x * (float)selectionoptions), selectionoptions - 1)];

        if (SelectedLightGroup == 1) {
            LightData Light = _UnityLights[SelectUnityLight(pixel_index, RunningWeight, norm, pos, PrevDirection)];
            float sinPhi, cosPhi;
            LightPosition = Light.Position;
            LightNorm = Light.Direction;
            LightFormat = Light.Type;
            Radiance = Light.Radiance;
            float3 RandVec = float3(random(115, pixel_index), random(116, pixel_index).x);
            MiscInfo = float3(Light.Softness * 120.0f + 1, Light.SpotAngle);
            if(LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) {
                sincos(Light.ZAxisRotation, sinPhi, cosPhi);
            }
            [branch] switch (LightFormat) {
                case POINTLIGHT:
                    LightNorm = normalize(ray.origin - LightPosition);
                    LightPosition += normalize(RandVec - 0.5f) * random(116, pixel_index).y * Light.Softness * 0.1f;//Soft Shadows
                break;
                case DIRECTIONALLIGHT:
                    LightPosition = ray.origin + LightNorm;
                    LightNorm = -LightNorm;
                     sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * Light.Softness* 0.01f;
                    if(Light.Softness* 0.01f > 0.001f) {
                        LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    }
                    Radiance *= GetSkyTransmittance(ray.origin, -LightNorm, 0, -LightNorm);
                    Radiance = DeSat(Radiance, 1.0f - SunDesaturate);
                break;
                case SPOTLIGHT:
                    LightPosition += normalize(RandVec - 0.5f) * random(116, pixel_index).y * Light.Softness * 0.1f;//Soft Shadows
                break;
                case AREALIGHTQUAD:
                    RandVec.xy = RandVec.xy * Light.SpotAngle - Light.SpotAngle / 2.0f;
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy);
                    LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    area = (Light.SpotAngle.x * Light.SpotAngle.y) / 2.0f;
                    if(hitDat.MatType == 3) Radiance = 0;
                break;
                case AREALIGHTDISK:
                    sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * Light.SpotAngle.x;
                    LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    area = PI * Light.SpotAngle.x * Light.SpotAngle.x;
                break;
            }
        } else if(SelectedLightGroup == 0) {
            #ifdef LBVH
                int MeshIndex;
                float4x4 MeshTransformInverse;
            #else
                int MeshIndex = SelectLightMeshSmart(pixel_index, RunningWeight, pos);
                float4x4 MeshTransformInverse = _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].W2L;
            #endif
            AggTriIndex = SelectLight(pixel_index, MeshIndex, RunningWeight, norm, pos, MeshTransformInverse, Radiance, LightPosition);
            #ifdef LBVH
                MeshTransformInverse = _MeshData[MeshIndex].W2L;
            #endif
            TrianglePos CurTri = triangle_get_positions(AggTriIndex);
            MeshTransformInverse = inverse(MeshTransformInverse);
            float3 a1 = mul((float3x3)MeshTransformInverse, CurTri.posedge1).xyz;
            float3 a2 = mul((float3x3)MeshTransformInverse, CurTri.posedge2).xyz;
            area = AreaOfTriangle(float3(0,0,0), a1, a2);
            LightPosition = mul(MeshTransformInverse, float4(LightPosition,1));
            LightNorm = normalize(mul((float3x3)MeshTransformInverse, normalize(cross(CurTri.posedge1, CurTri.posedge2))).xyz);
        } else {
            LightFormat = DIRECTIONALLIGHT;
            AggTriIndex = 0;
            Radiance = SampleLI(pixel_index, RunningWeight, LightNorm) * BackgroundIntensity;
            LightPosition = ray.origin - LightNorm;
        }


        if(AggTriIndex != -1) {
            float3 to_light = LightPosition - ray.origin;

            float distance_to_light_squared = dot(to_light, to_light);
            float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

            to_light = to_light / distance_to_light;
            
            float SurfaceCos = dot(to_light, norm);//YES KEEP THIS, IT NOT ONLY IMPROVES PERFORMANCE BUT IT ALSO HELPS KEEPS THINGS LESS BIASED AS OTHERWISE THE NORMAL OFFSET CAN RESULT IN WRONG VISABILITY!
            if(SurfaceCos > 0) {
                float bsdf_pdf = 0.0f;
                float3 bsdf_value = 0.0f;
                #ifndef RadianceCache
                    if((UseReSTIRGI && CurBounce == 0) || (UseASVGF && (CurBounce == Color.Data.w - 1 && CurBounce > 0))) hitDat.surfaceColor = 1.0f;
                #endif
                bool validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_value, pixel_index);
                #ifndef RadianceCache
                    if((UseASVGF && (CurBounce == Color.Data.w - 1 && CurBounce > 0))) bsdf_value *= Color.Data.xyz;
                #endif

                if (validbsdfNEE) {
                    float NEE_pdf;
                    float3 Illum;
                    [branch]if (SelectedLightGroup == 1) {
                        NEE_pdf = distance_to_light_squared * abs(dot(to_light, LightNorm)) / area;
                        Illum = Color.throughput * (Radiance * bsdf_value) / NEE_pdf * RunningWeight * ((LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) ? (MiscInfo.x) : 1.0f);
                    } else if(SelectedLightGroup == 0) {        
                        NEE_pdf = (1.0f / ((abs(dot(to_light, LightNorm)) * area) / distance_to_light_squared)) / RunningWeight;
                        #ifndef LBVH
                            NEE_pdf /= LightMeshCount;
                        #endif
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = Color.throughput * (Radiance * bsdf_value) / NEE_pdf * NEEMISWeight;
                    } else {
                        NEE_pdf = HDRIParams.x * HDRIParams.y * equirectDirectionPdf(to_light) * (luminance(Radiance) / TotSum[0]);
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = Color.throughput * (Radiance * bsdf_value) / NEE_pdf * RunningWeight * NEEMISWeight;
                    }
                    if(LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) Illum *= pow(saturate(dot(to_light, -LightNorm)), MiscInfo.x);
                    if (LightFormat == SPOTLIGHT) Illum *= saturate(saturate(dot(to_light, -LightNorm)) * MiscInfo.y + MiscInfo.z);
                    float maxillum = max(max(Illum.x, Illum.y), Illum.z);
                    if(DoExposure) maxillum *= Exposure[0];
                    if(!UseRussianRoulette || (CurBounce == 0 && ImprovedPrimaryHit)) maxillum = 1;
                    Illum *= rcp(saturate(maxillum));
                    if(bsdf_pdf > 0.0001f && maxillum > random(117, pixel_index).y) {//NEE russian roulette, massively improves performance while giivng the same result
                        uint index3;
                        #ifdef RadianceCache
                            bool TempTemp = !(((CacheInstance.pathLength >> 5) & 0x1) && !((CacheInstance.pathLength >> 6) & 0x1));
                            if(UseReSTIRGI && !TempTemp) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    
                        #else
                            bool TempTemp = (CurBounce != Color.Data.w - 1);
                            if(UseReSTIRGI && CurBounce == 0) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    
                        #endif            
                        const ShadowRayData ShadRay = {ray.origin, 
                                                        asfloat(packRGBE(bsdf_value)), 
                                                        to_light, 
                                                        (LightFormat == DIRECTIONALLIGHT ? 10000.0f : distance_to_light - 0.01f) * (TempTemp ? 1 : -1),
                                                        Illum, 
                                                        pixel_index};
                        if(TerrainExists) InterlockedAdd(BufferSizes[CurBounce].heightmap_shadow_rays, 1, index3);
                        InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
                        ShadowRaysBuffer[index3] = ShadRay;
                    }
                }
            }
        }
    }

    if (!validBSDFSample) return;//If the ray failed, we have no choice but to terminate this path

    if (CurBounce > 0 && UseRussianRoulette && Color.Data.w != -1) {
        float3 AdjustedCol = throughput * (ImprovedPrimaryHit ? 1.0f : Color.Data.xyz);
        float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
        if (random(118, pixel_index).x > p)//Simple Russian Roulette
            return;
        throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
    }

    Color.throughput = throughput;

    if(CB) {
        uint index2;//Congrats, the ray will continue its path
        InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
        if(TerrainExists) InterlockedAdd(BufferSizes[CurBounce + 1].heighmap_rays, 1, index2);
        const RayData GlobalRay = {ray.origin, pixel_index, ray.direction, pdf,set2(hit)};
        [branch]if(CurBounce % 2 == 0) index2 += screen_width * screen_height;
        GlobalRays[index2] = GlobalRay;

    }
}

[numthreads(64, 1, 1)]
void kernel_shade(uint3 id : SV_DispatchThreadID) {

    if (CurBounce != 0 && (id.x >= BufferSizes[CurBounce - 1].tracerays)) return;
    [branch]if(CurBounce % 2 == 1) id.x += screen_width * screen_height;
    const RayData GlobRay = GlobalRays[id.x];
    uint pixel_index = GlobRay.PixelIndex;
    id.xy = uint2(pixel_index % screen_width, pixel_index / screen_width);
    SmallerRay ray;
    RayHit bestHit = get2(GlobRay.hits);
    ray.origin = GlobRay.origin;
    ray.direction = GlobRay.direction;

    #ifdef HardwareRT
        if(bestHit.mesh_id != 9999999) {
            int2 Indexes = Unpack1To2(bestHit.mesh_id);
            int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.y].x + Indexes.x];
            bestHit.triangle_id += triangleOffset;
            bestHit.mesh_id = MeshOffsets[Indexes.y].y;
        }
    #endif
    ColData Color = GlobalColors[pixel_index];
    if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
        float3 Radiance, transmittance, debug = 0;
        float Stars;
        float2 uv;
        float mis = 1;
        [branch]switch(BackgroundType) {
            case 0:
                Radiance = saturate(1.0f - exp(-GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance, debug) * 15.0f));
                Radiance += debug;
                if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) Radiance += clamp((Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f)))) / 100.0f, 0, 10.0f);
                Stars = stars(ray.origin, ray.direction, toSpherical(ray.direction.xzy).yz, 0) * (1.0f - tanh_approx(0));
                Stars *= smoothstep(0,4.0f, (dot(SunDir, float3(0,-1,0))));
                if(Color.Data.w <= 0) Radiance += saturate(luminance(transmittance)) * Stars;

                if (all(Radiance < 10000.0f)) {
                    if (CurBounce == 0) Color.Direct = Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                    else if (CurBounce == 1) Color.Direct += Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                    else Color.Indirect += Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                    #ifdef RadianceCache
                        if(!UseReSTIRGI || ReSTIRGIUpdateRate == 0 || RandomNums[id.xy].z == 0)
                            AddMissToCache(CacheBuffer[pixel_index], Color.throughput * Radiance * BackgroundIntensity);
                    #endif
                }
            break;
            case 1:
                uv = equirectDirectionToUv(ray.direction);
                if(UseNEE && CurBounce > 0)
                    mis = power_heuristic(GlobRay.last_pdf, HDRIParams.x * HDRIParams.y * equirectDirectionPdf(ray.direction) * (luminance(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz) / TotSum[0]));
                if (CurBounce == 0) Color.Direct = _SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity;
                if (CurBounce == 1) Color.Direct += DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity,1.0f - SkyDesaturate) * mis;
                else Color.Indirect += Color.throughput * DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity,1.0f - SkyDesaturate) * mis;
                #ifdef RadianceCache
                    AddMissToCache(CacheBuffer[pixel_index], Color.throughput * DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity,1.0f - SkyDesaturate) * mis * abs(dot(i_octahedral_32(CacheBuffer[pixel_index].Norm), ray.direction)));
                #endif
            break;
            case 2:
                if (CurBounce == 0) Color.Direct = BackgroundColor * BackgroundIntensity;
                else if (CurBounce == 1) Color.Direct += BackgroundColor * BackgroundIntensity;
                else Color.Indirect += Color.throughput * BackgroundColor * BackgroundIntensity;
                #ifdef RadianceCache
                    AddMissToCache(CacheBuffer[pixel_index], Color.throughput * BackgroundColor * abs(dot(i_octahedral_32(CacheBuffer[pixel_index].Norm), ray.direction)));
                #endif
            break;
        }
        if(CurBounce == 0) Color.Data = float4(Color.Direct,0);
        GlobalColors[pixel_index] = Color;
        if(UseReSTIRGI && CurBounce == 1 && Color.Data.w == -1) {
            ScreenSpaceInfo[id.xy] = float4(ScreenSpaceInfo[id.xy].xyz, asfloat(packRGBE(max(Color.throughput, 0.005f)))); 
        }
        return;
    }
    float4 PrevScreenData = (!UseASVGF && CurBounce == 0) ? 0 : ScreenSpaceInfo[id.xy];
    float2 BaseUv;
    int MaterialIndex;
    bool HitTerrain = false;
    MaterialData TempMat;
    [branch]if (TerrainExists && (bestHit.mesh_id == 9999999)) {//if hit terrain
        BaseUv = float2(bestHit.u, bestHit.v);
        float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, BaseUv * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);
        int x = 0;
        float minmat = Mats.x;
        if(minmat < Mats.y) {
            minmat = Mats.y;
            x = 1;
        }
        if(minmat < Mats.z) {
            minmat = Mats.z;
            x = 2;
        }
        if(minmat < Mats.a) {
            minmat = Mats.a;
            x = 3;
        }

        minmat = 0;
        float3 BaseCol = 0;
        MaterialIndex = MaterialCount + Terrains[bestHit.triangle_id].MatOffset;
        if(Mats.x > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex].surfaceColor.xy + _Materials[MaterialIndex].transmittanceColor.xy, _Materials[MaterialIndex].AlbedoTexScale, _Materials[MaterialIndex].AlbedoTex, true), 0).xyz * Mats.x;
        if(Mats.y > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex + 1].surfaceColor.xy + _Materials[MaterialIndex + 1].transmittanceColor.xy, _Materials[MaterialIndex + 1].AlbedoTexScale, _Materials[MaterialIndex + 1].AlbedoTex, true), 0).xyz * Mats.y;
        if(Mats.z > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex + 2].surfaceColor.xy + _Materials[MaterialIndex + 2].transmittanceColor.xy, _Materials[MaterialIndex + 2].AlbedoTexScale, _Materials[MaterialIndex + 2].AlbedoTex, true), 0).xyz * Mats.z;
        if(Mats.w > 0.001f) BaseCol += _TextureAtlas.SampleLevel(my_point_clamp_sampler,  AlignUV(BaseUv * _Materials[MaterialIndex + 3].surfaceColor.xy + _Materials[MaterialIndex + 3].transmittanceColor.xy, _Materials[MaterialIndex + 3].AlbedoTexScale, _Materials[MaterialIndex + 3].AlbedoTex, true), 0).xyz * Mats.w;
        MaterialIndex += x;
        TempMat = _Materials[MaterialIndex];
        BaseUv = BaseUv * TempMat.surfaceColor.xy + TempMat.transmittanceColor.xy;
        TempMat.surfaceColor = BaseCol;
        HitTerrain = true;
    } else {
        BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat;
        TempMat = _Materials[MaterialIndex];
    }

    if(TempMat.Rotation != 0) {TempMat.Rotation *= PI;} 
    float2 AlbedoUv = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.AlbedoTex, TempMat.Rotation, true);
    float2 NormalUV = AlignUV(BaseUv, float4(TempMat.SecondaryTexScale, TempMat.AlbedoTexScale.zw), TempMat.NormalTex, TempMat.Rotation);
    float2 MetallicUV = AlignUV(BaseUv, float4(TempMat.SecondaryTexScale, TempMat.AlbedoTexScale.zw), TempMat.MetallicTex, TempMat.Rotation);
    float2 RoughnessUV = AlignUV(BaseUv, float4(TempMat.SecondaryTexScale, TempMat.AlbedoTexScale.zw), TempMat.RoughnessTex, TempMat.Rotation);
    

    if(TempMat.MatType == VideoIndex) {
        TempMat.surfaceColor = VideoTex.SampleLevel(sampler_VideoTex, BaseUv, 0).xyz;
    } else if(AlbedoUv.x != -1 && !HitTerrain) {
        #ifdef PointFiltering
            TempMat.surfaceColor *= _TextureAtlas.SampleLevel(my_point_clamp_sampler, AlbedoUv, 0).xyz;
        #else
            TempMat.surfaceColor *= _TextureAtlas.SampleLevel(my_linear_clamp_sampler, AlbedoUv, 0).xyz;
        #endif
        float3 TempCol = TempMat.surfaceColor;
        #ifndef DX11
            Unity_Hue_Degrees_float(TempCol, TempMat.Hue * 500.0f, TempMat.surfaceColor);
        #endif
        TempMat.surfaceColor *= TempMat.Brightness;
        TempCol = TempMat.surfaceColor;
        Unity_Saturation_float(TempCol, TempMat.Saturation, TempMat.surfaceColor);
        TempCol = TempMat.surfaceColor;
        Unity_Contrast_float(TempCol, TempMat.Contrast, TempMat.surfaceColor);
        TempMat.surfaceColor = saturate(TempMat.surfaceColor);
        TempMat.surfaceColor = lerp(TempMat.surfaceColor, TempMat.BlendColor, TempMat.BlendFactor);
    }

    #ifdef LightMapping
        if(CurBounce == 0) TempMat.surfaceColor = 1;
    #endif
    if (TempMat.specTrans != 1 && MetallicUV.x > 0) {float Tempmet = SingleComponentAtlas.SampleLevel(my_linear_clamp_sampler, MetallicUV, max(CurBounce, 0)); TempMat.metallic = Tempmet;}
    if(GetFlag(TempMat.Tag, UseSmoothness))  TempMat.roughness = 1.0f - TempMat.roughness;
    if (RoughnessUV.x > 0) TempMat.roughness = (GetFlag(TempMat.Tag, InvertSmoothnessTexture) ? (1.0f - saturate(SingleComponentAtlas.SampleLevel(my_linear_clamp_sampler, RoughnessUV, max(CurBounce, 0)))) : saturate(SingleComponentAtlas.SampleLevel(my_linear_clamp_sampler, RoughnessUV, max(CurBounce, 0))));
    TempMat.metallic = saturate(TempMat.metallic);
    if(!all(TempMat.MetallicRemap == float2(0,1))) TempMat.metallic = (TempMat.metallic * (TempMat.MetallicRemap.y - TempMat.MetallicRemap.x)) + TempMat.MetallicRemap.x;
    if(!all(TempMat.RoughnessRemap == float2(0,1))) TempMat.roughness = (TempMat.roughness * (TempMat.RoughnessRemap.y - TempMat.RoughnessRemap.x)) + TempMat.RoughnessRemap.x;

    TempMat.roughness = max(TempMat.roughness, 0.00001f);
    TempMat.surfaceColor = max(TempMat.surfaceColor, 0.005f);

    #ifndef WhiteLights
        if(TempMat.emmissive > 0) {
            float2 EmissionUV = AlignUV(BaseUv, TempMat.AlbedoTexScale, TempMat.EmissiveTex);    
            if (EmissionUV.x != -1) {
                float3 EmissCol = lerp(_Materials[MaterialIndex].EmissionColor, TempMat.surfaceColor, GetFlag(TempMat.Tag, BaseIsMap));
                float4 EmissTexture = _EmissiveAtlas.SampleLevel(my_linear_clamp_sampler, EmissionUV, 0);
                if(!GetFlag(TempMat.Tag, IsEmissionMask)) {//IS a mask
                    TempMat.emmissive *= luminance(EmissTexture.xyz);
                    TempMat.surfaceColor = lerp(TempMat.surfaceColor, EmissCol, saturate(TempMat.emmissive) * GetFlag(TempMat.Tag, ReplaceBase));
                } else {//is NOT a mask
                    TempMat.surfaceColor = lerp(TempMat.surfaceColor, EmissTexture.xyz * EmissCol, saturate(TempMat.emmissive) * GetFlag(TempMat.Tag, ReplaceBase));
                }            
            }
        }
    #endif
    float4 PrevScreen = PrevScreenData;
    #ifdef RadianceCache
        calcFinalColor(ray, Color, TempMat, bestHit, id.xy, NormalUV, GlobRay, pixel_index, MaterialIndex, BaseUv, PrevScreenData, CacheBuffer[pixel_index]);
    #else
        calcFinalColor(ray, Color, TempMat, bestHit, id.xy, NormalUV, GlobRay, pixel_index, MaterialIndex, BaseUv, PrevScreenData);
    #endif
    if(CurBounce == 0 || ((CurBounce == 1 || !UseReSTIRGI) && any(PrevScreen != PrevScreenData))) ScreenSpaceInfo[id.xy] = PrevScreenData;
    GlobalColors[pixel_index] = Color;

}





float IndirectBoost;

#ifdef HDRP
    Texture2DArray<float4> DiffuseGBuffer;
    Texture2DArray<float4> SpecularGBuffer;
    Texture2DArray<float4> NormalTexture;
    Texture2DArray<float> Depth;
#else
    Texture2D<float4> DiffuseGBuffer;
    Texture2D<float4> SpecularGBuffer;
    Texture2D<float4> NormalTexture;
    Texture2D<float> Depth;
#endif

#pragma kernel kernel_finalize

[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance
    if (id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;

    float3 GBufferCol = 1;
    [branch]if(DiffRes) {
        float2 UV = id.xy / float2(screen_width, screen_height);
        #ifdef HDRP
            float3 SpecularAlbedo = 0;
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        #else
            float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        #endif
    }
    float3 res = (GlobalColors[final_pixel_index].Data.w == 0) ? GlobalColors[final_pixel_index].Data.xyz : ((float)PartialRenderingFactor * ((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * GlobalColors[final_pixel_index].Data.xyz + pow(unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay),2.2f)) / GBufferCol);
    if (!all(res < 100000)) res = 0;
    #if defined(RadianceDebug) && defined(RadianceCache)
        res = 0;
        RetrieveCacheRadiance(CacheBuffer[final_pixel_index], _DebugTex[id.xy].xyz, i_octahedral_32(asuint(_DebugTex[id.xy].w)), res);
    #endif
    Result[id.xy] = float4(res, 1.0f);
}


#pragma kernel TransferKernel
int Type;
[numthreads(1, 1, 1)]
void TransferKernel(uint3 id : SV_DispatchThreadID) {
    if(Type == 0) {
        BufferData[0] = uint3(ceil(BufferSizes[CurBounce].tracerays / 64.0f), 1, 1);
        if(CurBounce != 0) BufferSizes[CurBounce - 1].tracerays = BufferSizes[CurBounce].tracerays;
    } else {
          BufferData[0] = uint3(ceil(BufferSizes[CurBounce].shadow_rays / 64.0f), 1, 1);
    }

}

#pragma kernel DepthCopyKernel

float FetchDepth(float2 UV) {
    Ray ray = CreateCameraRay(UV * 2.0f - 1.0f);  
    #ifdef HDRP
        float depth = 1.0f - (Depth[int3(UV * float2(screen_width, screen_height),0)].x);
    #else
        float depth = 1.0f - (Depth.SampleLevel(my_linear_clamp_sampler, UV, 0).x);
    #endif
        depth = NearPlane * FarPlane / (depth * (NearPlane - FarPlane) + FarPlane);
        return length(ray.direction / dot(ray.direction, Forward) * depth);   
}

[numthreads(32, 32, 1)]
void DepthCopyKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x > screen_width || id.y > screen_height) return;
    float2 Uv = (id.xy + 0.5f) / float2(screen_width, screen_height);

    float CurDepth = FetchDepth(Uv);
    float CurDepthX = FetchDepth(Uv + float2(rcp(screen_width) * 2.0f, 0));
    float CurDepthY = FetchDepth(Uv + float2(0, rcp(screen_height) * 2.0f));
    float CurDepthX2 = FetchDepth(Uv - float2(rcp(screen_width) * 2.0f, 0));
    float CurDepthY2 = FetchDepth(Uv - float2(0, rcp(screen_height) * 2.0f));
    CorrectedDepthTex[id.xy] = float2(CurDepth, abs(CurDepth - CurDepthX) + abs(CurDepth - CurDepthY) + abs(CurDepth - CurDepthY2) + abs(CurDepth - CurDepthX2));
}



RWStructuredBuffer<float3> OutputBuffer;
RWStructuredBuffer<float3> AlbedoBuffer;
RWStructuredBuffer<float3> NormalBuffer;

#pragma kernel OIDNtoTTKernel
[numthreads(16, 16, 1)]
void OIDNtoTTKernel(uint3 id : SV_DispatchThreadID) {
    Result[id.xy] = float4(OutputBuffer[id.x + id.y * screen_width], 1);
}

#pragma kernel TTtoOIDNKernel
[numthreads(16, 16, 1)]
void TTtoOIDNKernel(uint3 id : SV_DispatchThreadID) {
    int pixel_index = id.x + id.y * screen_width;
    float3 GBufferCol = 1;
    float2 UV = id.xy / float2(screen_width, screen_height);
    #ifdef HDRP
        float3 SpecularAlbedo = 0;
        GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        NormalBuffer[pixel_index] = NormalTexture.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz * 2.0f - 1.0f;
    #else
        float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
        GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        NormalBuffer[pixel_index] = NormalTexture.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz * 2.0f - 1.0f;
    #endif
    AlbedoBuffer[pixel_index] = GBufferCol;
    OutputBuffer[id.x + id.y * screen_width] = Result[id.xy].xyz;
}